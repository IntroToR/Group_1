---
title: "Group_1_Project"
author: "Matthew Runyon, Winston Wong, & Leo D'Agostino"
date: "10/16/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The data set that we have chosen to work with is the "Volcano Eruptions" data set, coming from Week 20 of the 2020 TidyTuesday project. This data is provided by the Smithsonian Institute. The data, which is split into five files (`volcano`, `eruptions`, `events`, `tree_rings`, and `sulfur`) can be read in using the first half of the following code. Following that, we created the file paths to save various data sets, figures, and summary tables. Finally, we saved each of these files within the actual `Data_Sets` file on GitHub using the second half of code. As far as responsibilities for each of these files, Winston was responsible for data analysis on the `tree_rings` and `sulfur` data sets, Leo was responsible for investigating the `eruptions` data set, and Matthew was responsible for analyzing the `volcano` data set. Everyone provided assistance across data sets with code formatting to bolster the appearance after preliminary analyses had been completed independently. We chose not to delve into the `events` file because it was mainly date information without many other important variables to work with.

```{r}
volcano <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-05-12/volcano.csv')
eruptions <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-05-12/eruptions.csv')
events <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-05-12/events.csv')
tree_rings <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-05-12/tree_rings.csv')
sulfur <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-05-12/sulfur.csv')

data_sets_path<-"C:/Users/mrunyon2/Documents/Classes/Fall 2020/CPSC 441/Group_1/Data_Sets"
figure_path<-"C:/Users/mrunyon2/Documents/Classes/Fall 2020/CPSC 441/Group_1/Figures"
summary_text_path<-"C:/Users/mrunyon2/Documents/Classes/Fall 2020/CPSC 441/Group_1/Summary_Text_files"

write.table(volcano, file.path(data_sets_path, "volcano.txt"))
write.table(eruptions, file.path(data_sets_path, "eruptions.txt"))
write.table(events, file.path(data_sets_path, "events.txt"))
write.table(tree_rings, file.path(data_sets_path, "tree_rings.txt"))
write.table(sulfur, file.path(data_sets_path, "sulfur.txt"))
```

__Loading Relevant Packages__

Here we load all of the relevant packages that will be used with our project. This ensures that all packages will be loaded at the start so that there is no redundancy within the code.
```{r}
library(tidyverse)
library(car)
library(ggpubr)
library(threejs)
library(qwraps2)
library(agricolae)
```

__Sulfur Concentration Dataset__

The sulfur concentration data set contains three variables. Two are sulfur content in ng/g collected from NEEM and WDC ice cores, which were collected from Greenland and Antarctica, respectively. These are treated as the response variables. The independent variable is the year, which is approximated as the time that the sulfur depositions took place.

___Summary Statistics and Means___

First, we are presenting summary statistics of this data. This is done by constructing a summary table based on the `qwraps2` package. Then, we save the means of the data set in a separate text file using the code below. Since there are only two numeric variables in this data set, this is not a large file on its own.
```{r}
sulfur_summary <-
  list("NEEM" =
       list("min_neem"       = ~ min(sulfur$neem, na.rm=T),
            "max_neem"       = ~ max(sulfur$neem, na.rm=T),
            "median_neem"    = ~ median(sulfur$neem, na.rm=T),
            "mean_neem"      = ~ mean(sulfur$neem, na.rm=T),
            "variance_neem"  = ~ var(sulfur$neem, na.rm=T),
            "stdev_neem"     = ~ sd(sulfur$neem, na.rm=T)),
       "WDC" =
       list("min_wdc"       = ~ min(sulfur$wdc, na.rm=T),
            "max_wdc"       = ~ max(sulfur$wdc, na.rm=T),
            "median_wdc"    = ~ median(sulfur$wdc, na.rm=T),
            "mean_wdc"      = ~ mean(sulfur$wdc, na.rm=T),
            "variance_wdc"  = ~ var(sulfur$wdc, na.rm=T),
            "stdev_wdc"     = ~ sd(sulfur$wdc, na.rm=T))
       )
sulfur_summary_table<-as.data.frame(summary_table(sulfur, summaries=sulfur_summary))
sulfur_summary_table

sulfur_means<-data.frame(mean(sulfur$neem, na.rm=T), mean(sulfur$wdc, na.rm=T))
names(sulfur_means)<-c("NEEM_mean", "WDC_mean")
row.names(sulfur_means)<-c("overall_mean_sulfur_content")
write.table(sulfur_means, file.path(summary_text_path, "sulfur_dataset_overall_means.txt"))
```

Plotted below is a simple line graph showing sulfur concentration in ice cores across years of deposition. We can see several major spikes in sulfur content, which are indicative of volcanic eruptions that have sent high-sulfur ash into the air. Notable peaks in the NEEM core data are around 525 AD, 540 AD, 575 AD, 625 AD, and 685 AD, while notable peaks in the WDC core data are around 550 AD, 575 AD, and 685 AD. For several of these major peaks, there appears to be overlap between the data sets. This is particularly interesting because these would signify major volcanic eruptions, as cores were pulled from ice samples near poles at opposite ends of the world.
```{r}
ggplot(sulfur, aes(x=year, y=neem))+
  geom_line()+
  ggtitle("Sulfur Concentration per Year from NEEM Ice Cores")+
  labs(x="Year (AD)", y="Sulfur Content (ng/g)")+
  theme(panel.grid=element_blank())+
  ggsave(file.path(figure_path, "neem_sulfur_across_years.pdf"))

ggplot(sulfur, aes(x=year, y=wdc))+
  geom_line()+
  ggtitle("Sulfur Concentration per Year from WDC Ice Cores")+
  labs(x="Year (AD)", y="Sulfur Content (ng/g)")+
  theme(panel.grid=element_blank())+
  ggsave(file.path(figure_path, "wdc_sulfur_across_years.pdf"))
```

___Linear Regression Analysis of Sulfur Content vs. Year and NEEM vs. WDC Sulfur Content___

Here, we conduct linear regression to evaluate whether there is a significant linear relationship between year and sulfur content in either of the two locations.

First we will construct the model, then we will evaluate the assumptions to see if building that model is appropriate for this data set. Building a linear model allows us to establish a relationship between year and sulfur levels at NEEM and WDC locations in the form of sulfur levels as a function for year. Null and alternative hypotheses for each of the models are provided, followed by linear models themselves for sulfur levels at both locations are shown below. Slope and intercept values are provided upon calling the model.
```{r}
#Linear model for Sulfur levels at NEEM
#Ho: Slope = 0 (no linear relationship)
#HA: Slope not equal to 0 (linear relationship)
NEEM_linear_model <- lm(neem ~ year, data = sulfur)
NEEM_linear_model

#Linear model for Sulfur levels at WDC
#Ho: Slope = 0 (no linear relationship)
#HA: Slope not equal to 0 (linear relationship)
WDC_linear_model <- lm(wdc ~ year, data = sulfur) 
WDC_linear_model

#Linear model for NEEM vs. WDC
#Ho: Slope = 0 (no linear relationship)
#HA: Slope not equal to 0 (linear relationship)
NEEMvsWDC_linear_model <-lm(wdc~neem, data = sulfur)
NEEMvsWDC_linear_model
```

After forming these three linear models, we can to test for correlation between year vs. sulfur concentrations in both locations and correlation between NEEM and WDC sulfur content. We will  test for correlation using the Pearson's "r". Based off of these values, we can conclude that there is an extremely weak linear correlation among the variables of interest, negative for the first two models and positive for the third.
```{r}
#Year vs NEEM
cor(sulfur$year, sulfur$neem, method = "pearson", use = "complete.obs")

#Year vs WDC
cor(sulfur$year, sulfur$wdc, method = "pearson", use = "complete.obs")

#NEEM vs WDC
cor(sulfur$neem, sulfur$wdc, method = "pearson", use = "complete.obs")
```

By running the `summary()` below function, we can determine the significance of our models. Our conclusions are noted as follows:

1) Year vs NEEM: p = 0.36. At alpha = 0.05, we fail to reject the null hypothesis and conclude that no significant linear relationship exists between year and NEEM sulfur content.

2) Year vs WDC: p = 0.0003. At alpha = 0.05, we reject the null hypothesis and conclude that there is a significant linear relationship between year and WDC sulfur content.

3) NEEM vs WDC: p = 3.2 x 10E-8. At alpha = 0.05, we reject the null hypothesis and conclude that there is a significant linear relationship between sulfur content at NEEM and WDC.
```{r}
#model summary for sulfur levels at NEEM
summary(NEEM_linear_model) 

#model summary for sulfur levels at WDC
summary(WDC_linear_model)  

#model summary for NEEM vs. WDC
summary(NEEMvsWDC_linear_model)
```

Now that we have constructed models and determined that a linear relationship was observed for two of the three models, we need to test the assumptions to determine whether linear regression was appropriate for this data. We can first create scatter plots to visualize a possible linear relationship between the independent and dependent variables. From the scatterplot it does not appear that there is a linear relationship between year and sulfur concentration at either location, nor between the two sulfur contents. Under normal circumstances, we would conclude that linear regression is inappropriate because there doesn't appear to be visual linear trend; nonetheless, for demonstration purposes, we are continuing with the process. We demonstrate the correlation coefficient and significance level on the charts using the `stat_cor()` function from the `ggpubr` package, as well as a confidence interval using the `geom_smooth()` function. We will continue to check the assumptions for demonstration purposes.
```{r}
ggplot(sulfur, aes(x=year, y=neem))+
  geom_point(alpha=1/5)+
  ggtitle("Year vs NEEM Sulfur Content (ng/g)")+
  labs(x="Year", y="NEEM Sulfur Content (ng/g)")+
  theme(panel.grid=element_blank())+
  stat_cor()+
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)+
  ggsave(file.path(figure_path, "year_vs_neem_correlation.pdf"))

ggplot(sulfur, aes(x=year, y=wdc))+
  geom_point(alpha=1/5)+
  ggtitle("Year vs WDC Sulfur Content (ng/g)")+
  labs(x="Year", y="WDC Sulfur Content (ng/g)")+
  theme(panel.grid=element_blank())+
  stat_cor()+
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)+
  ggsave(file.path(figure_path, "year_vs_wdc_correlation.pdf"))

ggplot(sulfur, aes(x=neem, y=wdc))+
  geom_point(alpha=1/5)+
  ggtitle("NEEM Sulfur Content (ng/g) vs WDC Sulfur Content (ng/g)")+
  labs(x="NEEM Sulfur Content (ng/g)", y="WDC Sulfur Content (ng/g)")+
  theme(panel.grid=element_blank())+
  stat_cor()+
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)+
  ggsave(file.path(figure_path, "neem_vs_wdc_correlation.pdf"))

############################################ Winston, see what you think about the scatter plots that I included here; if you like them better, take out the ones below, but if you like the originals better, take out the ones above

#Scatter plot for Year vs. NEEM
scatter_YearvNEEM <- ggplot(data = sulfur, aes(x = year, y= neem)) +
                          geom_point(color = "yellow") +
                          ylab("Sulfur detected in ng/g") +
                          ggtitle("Sulfur detected in ng/g from NEEM") 

#Scatter plot for Year vs. WDC
scatter_YearvWDC <- ggplot(data = sulfur, aes(x = year, y= wdc)) +
                          geom_point(color = "orange") +
                          ylab("Sulfur detected in ng/g") +
                          ggtitle("Sulfur detected in ng/g from WDC") 

#Scatter plot for NEEM vs WDC
scatter_NEEMvWDC <- ggplot(data = sulfur, aes(x = neem, y= wdc)) +
                          geom_point(color = "blue") +
                          ylab("WDC sulfur levels in ng/g") +
                          xlab("NEEM sulfur levels in ng/g")+
                          ggtitle("NEEM vs. WDC Sulfur Levels ") 
```

Next, we can create boxplots to check for outliers for the variables `neem` and `wdc` sulfur concentrations. From both boxplots, we conclude that there are many outliers, and that the data from both data sets is heavily right skewed and not normally distributed. If we look instead at the residuals from each of the models, we can see that the residuals are likewise heavily right skewed and not normally distributed. Again in this case, this would normally disqualify us from carrying out linear regression.
```{r}
sulfur_long<-pivot_longer(sulfur, cols=c("neem", "wdc"), names_to="core_loc")
sulfur_long$core_loc<-as.factor(sulfur_long$core_loc)
write.table(sulfur_long, file.path(summary_text_path, "sulfur_dataset_pivot_long.txt"))

#Boxplots for distribution of raw data
ggplot(sulfur_long, aes(x=year, y=value))+
  geom_boxplot(col="black", fill="yellow")+
  ggtitle("Boxplots of Sulfur Content in Ice Core Samples")+
  labs(y="Sulfur (ng/g)", x="")+
  theme(panel.grid=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+
  facet_wrap(~core_loc)+
  ggsave(file.path(figure_path, "sulfur_distribution_boxplot.pdf"))

#Boxplots for distribution of residuals
neem_res<-as.data.frame(residuals(NEEM_linear_model))
wdc_res<-as.data.frame(residuals(WDC_linear_model))
neem_vs_wdc_res<-as.data.frame(residuals(NEEMvsWDC_linear_model))
sulfur_residuals<-cbind(neem_res, wdc_res, neem_vs_wdc_res)
sulfur_residuals_long<-pivot_longer(sulfur_residuals, cols=c("residuals(NEEM_linear_model)", "residuals(WDC_linear_model)", "residuals(NEEMvsWDC_linear_model)"), names_to="residual")

ggplot(sulfur_residuals_long, aes(y=value))+
  geom_boxplot(col="black", fill="orange")+
  ggtitle("Boxplots of Residuals for Sulfur Content Models")+
  labs(y="Residual Value", x="")+
  theme(panel.grid=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+
  facet_wrap(~residual)+
  ggsave(file.path(figure_path, "sulfur_resiudals_distribution_boxplot.pdf"))

################################### Winston, see what you think about the scatter plots that I included here; if you like them better, take out the ones below, but if you like the originals better, take out the ones above
  
#Boxplot for sulfur levels from NEEM created using base R
sulfur$neem<-as.numeric(sulfur$neem)
boxplot(sulfur$neem, main = "Sulfur detected in ng/g from NEEM",
        xlab = "sulfur (ng/g)", horizontal = TRUE)

#Boxplot for sulfur levels from NEEM created using ggplot2
ggplot(sulfur, aes(y=neem))+
  geom_boxplot()+
  ggtitle("Boxplot of NEEM Sulfur Concentrations")+
  labs(y="NEEM Sulfur Concentration (ng/g)")+
  theme(panel.grid=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())

#Boxplot for sulfur levels from WDC created using base R
WDCsulfur <- as.numeric(sulfur$wdc)
boxplot(sulfur$wdc, main = "Sulfur detected in ng/g from WDC",
        xlab = "sulfur (ng/g)", horizontal = TRUE)

#Boxplot for sulfur levels from WDC created using ggplot2
ggplot(sulfur, aes(y=wdc))+
  geom_boxplot()+
  ggtitle("Boxplot of WDC Sulfur Concentrations")+
  labs(y="WDC Sulfur Concentration (ng/g)")+
  theme(panel.grid=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())
```

Overall, even though we demonstrated that the Year vs WDC and NEEM vs WDC models were statistically significant, we have shown through testing the assumptions that linear regression is not an appropriate approach to take with this data set due to extreme non-normality and lack of a suggestive visible linear trend. Therefore, if we were to look at these variables in a more detailed approach, a data tranformation should be attempted, or an approach other than linear regression should be taken to test for relationship between these variables.

__Tree Ring Dataset__

Like the sulfur dataset, the tree ring data set contains three variables. Two response variables are the European temperature index and tree ring Z-scores. The European temperature index is a relative temperature index in degrees Celsius. The more ash that is spewed into the air from volcanic eruptions, the more sunlight should be reflected in the atmosphere, and the cooler the average temperature for a given year should be. Likewise, temperature and seasonal extremes should cause more variability in vegetative growth such as tree rings, and this variability should be reflected by larger Z scores. The independent variable is the year from which these measurements were taken, dating back 2,000 years.

___Summary Statistics and Means___

First, we present summary statistics of this data. As done with the sulfur data set, this is done by constructing a summary table based on the `qwraps2` package. Then, we save the means of the data set in a separate text file using the code below. Again, there are only two numeric values in this data file.
```{r}
tree_ring_summary <-
  list("n_tree" =
         list("min_n_tree"       = ~ min(tree_rings$n_tree, na.rm=T),
              "max_n_tree"       = ~ max(tree_rings$n_tree, na.rm=T),
              "median_n_tree"    = ~ median(tree_rings$n_tree, na.rm=T),
              "mean_n_tree"      = ~ mean(tree_rings$n_tree, na.rm=T),
              "variance_n_tree"  = ~ var(tree_rings$n_tree, na.rm=T),
              "stdev_n_tree"     = ~ sd(tree_rings$n_tree, na.rm=T)),
       "europe_temp_index" =
         list("min_europe_temp_index"       = ~ min(tree_rings$europe_temp_index, na.rm=T),
              "max_europe_temp_index"       = ~ max(tree_rings$europe_temp_index, na.rm=T),
              "median_europe_temp_index"    = ~ median(tree_rings$europe_temp_index, na.rm=T),
              "mean_europe_temp_index"      = ~ mean(tree_rings$europe_temp_index, na.rm=T),
              "variance_europe_temp_index"  = ~ var(tree_rings$europe_temp_index, na.rm=T),
              "stdev_europe_temp_index"     = ~ sd(tree_rings$europe_temp_index, na.rm=T))
  )
tree_ring_summary_table<-as.data.frame(summary_table(tree_rings, summaries=tree_ring_summary))
tree_ring_summary_table

tree_ring_means<-data.frame(mean(tree_rings$n_tree, na.rm=T), mean(tree_rings$europe_temp_index, na.rm=T))
names(tree_ring_means)<-c("n_tree_mean", "europe_temp_index_mean")
row.names(tree_ring_means)<-c("overall_means")
write.table(tree_ring_means, file.path(summary_text_path, "tree_ring_dataset_overall_means.txt"))
```
Plotted below are two line graphs showing the measurements of tree ring Z-scores and the European temperature index over time. As shown in these two graphs, the data is very noisy, with large swings from year to year. It is much more noisy than the ice core data. This likely is due to the imprecision of these measurements; since these date back before records were being taken and the data isn't preserved as exactly in time like it is for the sulfur in the ice cores, there is a lot more room for error from these estimations.
```{r}
ggplot(tree_rings, aes(x=year, y=n_tree))+
  geom_line()+
  ggtitle("Tree Ring Z-Scores per Year")+
  labs(x="Year (AD)", y="Z-Score")+
  theme(panel.grid=element_blank())+
  ggsave(file.path(figure_path, "tree_ring_scores_across_years.pdf"))

ggplot(tree_rings, aes(x=year, y=europe_temp_index))+
  geom_line()+
  ggtitle("European Temperature Index per Year")+
  labs(x="Year (AD)", y="European Temperature Index")+
  theme(panel.grid=element_blank())+
  ggsave(file.path(figure_path, "temp_index_across_years.pdf"))

```

___Linear Regression Analysis of Sulfur Content vs. Year and NEEM vs WDC Sulfur Content___

Here, we conduct linear regression to evaluate whether there is a significant linear relationship between year and tree ring Z-score, year and temperature index, and tree ring Z-score and temperature index.

First we will construct the representative models, then we will evaluate the assumptions to see if building that model is appropriate for this data set. Null and alternative hypotheses for each of the models are provided, followed by linear models themselves are shown below. Slope and intercept values are provided upon calling the model.

```{r}
#Linear model for year vs "n_tree"
#Ho: Slope = 0 (no linear relationship)
#HA: Slope not equal to 0 (linear relationship)
nTree_linear_model <- lm(n_tree ~ year, data = tree_rings)
nTree_linear_model

#Linear model for year vs. "europe_temp_index"
#Ho: Slope = 0 (no linear relationship)
#HA: Slope not equal to 0 (linear relationship)
ETI_linear_model <- lm(europe_temp_index ~ year, data = tree_rings) 
ETI_linear_model

#Linear model for "n_tree" vs. "europe_temp_index
#Ho: Slope = 0 (no linear relationship)
#HA: Slope not equal to 0 (linear relationship)
nTreevsETI_linear_model <-lm(europe_temp_index~n_tree, data = tree_rings)
nTreevsETI_linear_model
```

After forming these three linear models, we can to test for correlation between year vs. sulfur concentrations in both locations and correlation between NEEM and WDC sulfur content. We will  test for correlation using the Pearson's "r". Based off of these values, we can conclude that there is a weak negative relationship between year and tree ring Z-score and between year and European temperature index, and a strong positive linear correlation between tree ring Z-score and European temperature index.
```{r}
#Year vs n_tree
cor(tree_rings$year, tree_rings$n_tree, method = "pearson", use = "complete.obs")

#Year vs europe_temp_index
cor(tree_rings$year, tree_rings$europe_temp_index, method = "pearson", use = "complete.obs")

#n_tree vs europe_temp_index
cor(tree_rings$n_tree, tree_rings$europe_temp_index, method = "pearson", use = "complete.obs")
```

By running the `summary()` below function, we can determine the significance of our models. Our conclusions are noted as follows:

1) Year vs n_tree: p = 2.6E-11. At alpha = 0.05, we reject the null hypothesis and conclude that there is a significant linear relationship between year and tree ring Z-score.

2) Year vs europe_temp_index: p = 2.2E-16. At alpha = 0.05, we reject the null hypothesis and conclude that there is a significant linear relationship between year and European temperature index.

3) n_tree vs europe_temp_index: p = 2.2E-16. At alpha = 0.05, we reject the null hypothesis and conclude that there is a significant linear relationship between tree ring Z-score and European temperature index.
```{r}
#model summary for "n_tree" and year
summary(nTree_linear_model) 

#model summary for "europe_temp_index" and year
summary(ETI_linear_model)  

#model summary for "n_tree" vs. "europe_temp_index"
summary(nTreevsETI_linear_model)
```

Now that we have constructed models and determined that a linear relationship was observed for two of the three models, we need to test the assumptions to determine whether linear regression was appropriate for this data. We can first create scatter plots to visualize a possible linear relationship between the independent and dependent variables. From the scatterplot it is possible that there is a linear relationship between year and tree ring Z-score or year and European temperature index. However, it appears that there is a strong, positive linear relationship between tree ring Z-score and European temperature index, as was suggested by the linear model. Because a possible linear trend exists for all three sets of data, we will continue checking the model assumptions.

```{r}
ggplot(tree_rings, aes(x=year, y=n_tree))+
  geom_point(alpha=1/5)+
  ggtitle("Year vs Tree Ring Z-Score")+
  labs(x="Year", y="Tree Ring Z-Score")+
  theme(panel.grid=element_blank())+
  stat_cor()+
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)+
  ggsave(file.path(figure_path, "year_vs_tree_ring_correlation.pdf"))

ggplot(tree_rings, aes(x=year, y=europe_temp_index))+
  geom_point(alpha=1/5)+
  ggtitle("Year vs European Temperature Index")+
  labs(x="Year", y="European Temperature Index")+
  theme(panel.grid=element_blank())+
  stat_cor()+
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)+
  ggsave(file.path(figure_path, "year_vs_temp_index_correlation.pdf"))

ggplot(tree_rings, aes(x=n_tree, y=europe_temp_index))+
  geom_point(alpha=1/5)+
  ggtitle("Tree Ring Z-Score vs European Temperature Index")+
  labs(x="Tree Ring Z-Score", y="European Temperature Index")+
  theme(panel.grid=element_blank())+
  stat_cor()+
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)+
  ggsave(file.path(figure_path, "tree_ring_vs_temp_index_correlation.pdf"))

########################################### Winston, see what you think about the scatter plots that I included here; if you like them better, take out the ones below, but if you like the originals better, take out the ones above

#Scatter plot for Year vs. "n_Tree"
scatter_YearvnTree <- ggplot(data = tree_rings, aes(x = year, y= n_tree)) +
                          geom_point(color = "green") +
                          ylab("Tree ring z-scores relative to year = 1000-1099") +
                          ggtitle("Tree rings z-scores vs. Year") 

#Scatter plot for Year vs. "europe_temp_index"
scatter_YearvETI <- ggplot(data = tree_rings, aes(x = year, y= europe_temp_index)) +
                          geom_point(color = "red") +
                          ylab("Pages 2K Temperature for Europe in Celsius") +
                          ggtitle("Pages 2K Temperature for Europe in Celsius vs. Year") 

#Scatter plot for "n_tree" vs "europe_temp_index"
scatter_nTreevETI <- ggplot(data = tree_rings, aes(x = n_tree, y= europe_temp_index)) +
                          geom_point(color = "blue") +
                          ylab("Pages 2K Temperature for Europe in Celsius") +
                          xlab("Tree ring z-scores relative to year = 1000-1099")+
                          ggtitle("Tree ring z-scores vs. ETI in Celsius ") 
```

Next, we can create boxplots to check for outliers for the variables `n_tree` and `europe_temp_index` values. From both boxplots, we conclude that there are several outliers, but the data from both data appears normally distributed without skew. If we look instead at the residuals from each of the models, they also appear to follow a normal distribution for all three of the models. From this data, we can conclude that this assumption has been met.
```{r}
tree_rings_long<-pivot_longer(tree_rings, cols=c("n_tree", "europe_temp_index"), names_to="measurement_type")
tree_rings_long$measurement_type<-as.factor(tree_rings_long$measurement_type)
write.table(tree_rings_long, file.path(summary_text_path, "tree_rings_dataset_pivot_long.txt"))

#Boxplots for distribution of raw data
ggplot(tree_rings_long, aes(x=year, y=value))+
  geom_boxplot(col="black", fill="blue")+
  ggtitle("Boxplots of Tree Ring Z-Scores and European Temperature Indices")+
  labs(y="Value", x="")+
  theme(panel.grid=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+
  facet_wrap(~measurement_type)+
  ggsave(file.path(figure_path, "tree_ring_temp_index_distribution_boxplot.pdf"))

#Boxplots for distribution of residuals
n_tree_res<-as.data.frame(residuals(nTree_linear_model))
ETI_res<-as.data.frame(residuals(ETI_linear_model))
n_tree_ETI_res<-as.data.frame(residuals(nTreevsETI_linear_model))
tree_ring_residuals<-cbind(n_tree_res, ETI_res, n_tree_ETI_res)
tree_ring_residuals_long<-pivot_longer(tree_ring_residuals, cols=c("residuals(nTree_linear_model)", "residuals(ETI_linear_model)", "residuals(nTreevsETI_linear_model)"), names_to="residual")

ggplot(tree_ring_residuals_long, aes(y=value))+
  geom_boxplot(col="black", fill="green")+
  ggtitle("Boxplots of Residuals for Tree Ring Dataset Models")+
  labs(y="Residual Value", x="")+
  theme(panel.grid=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+
  facet_wrap(~residual)+
  ggsave(file.path(figure_path, "tree_ring_temp_index_residuals_distribution_boxplot.pdf"))

############################# Winston, see what you think about the scatter plots that I included here; if you like them better, take out the ones below, but if you like the originals better, take out the ones above

#Boxplot for "n_tree"
bp_nTree<- ggplot(tree_rings, aes(y=n_tree))+
  geom_boxplot(fill = "green")+
  ggtitle("Boxplot of Tree ring z-scores relative to year = 1000-1099") +
  labs(y="Tree ring z-scores ")+
  theme(panel.grid=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())

#Boxplot for "europe_temp_index"
bp_ETI <- ggplot(tree_rings, aes(y=europe_temp_index))+
  geom_boxplot(fill = "red")+
  ggtitle("Pages 2K Temperature for Europe in Celsius") +
  labs(y="Celsius ")+
  theme(panel.grid=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())
```

Overall, we have demonstrated that the assumptions for conducting linear regression have been met, so this form of analysis is appropriate. Based off of these models, we can conclude that there is a weak negative linear relationship between year and tree ring Z-score and between year and European temperature index, and a strong positive linear relationship between tree ring Z-score and European temperature index. As noisy as the data was from the initial line plot, these conclusions were rather interesting, as we wouldn't have thought that they would have lined up so well. However, it does make sense that vegetative growth of trees would be influenced by temperature, so this correlation is reasonable.

__Volcano Dataset__

The volcano data set contains multiple variables related to characteristics of known volcanos around the world. Some variables specify volcano location, such as `country`, `region`,`subregion`, `latitude`, and `longitude`. Other variables specify features of the volcano, such as `primary_volcano_type`, `tectonic_settings`, `elevation`, `last_eruption_year`, and various kinds of rock types that are characteristic of that volcano. Finally, human populations within 5, 10, 30, and 100 km of each volcano are provided.

___Data Cleanup___

First we cleaned up the data in the `primary_volcano_type` column by removing all duplicate values of plural classifiers (removed all (es) and (s)). Then we coverted this column, as well as `country`, `region`, `subregion`, `tectonic_settings`, `evidence_category`, `major_rock_.`, and `minor_rock_.` to factors. We also changed all the unknown `last_eruption_year` data with `NA` and converted those to numeric values. Finally, we arrange the data, create a new columns for years since the last eruption date using the `last_eruption_year` variable, and order the columns how we want them.


```{r}
volcano$primary_volcano_type<-gsub(".(es).", "", volcano$primary_volcano_type)
volcano$primary_volcano_type<-gsub(".(s).", "", volcano$primary_volcano_type)
volcano$primary_volcano_type<-sub("Stratovolcano.", "Stratovolcano", volcano$primary_volcano_type)
volcano$primary_volcano_type<-as.factor(volcano$primary_volcano_type)
volcano$country<-as.factor(volcano$country)
volcano$region<-as.factor(volcano$region)
volcano$subregion<-as.factor(volcano$subregion)
volcano$tectonic_settings<-as.factor(volcano$tectonic_settings)
volcano$evidence_category<-as.factor(volcano$evidence_category)
volcano$major_rock_1<-as.factor(volcano$major_rock_1)
volcano$major_rock_2<-as.factor(volcano$major_rock_2)
volcano$major_rock_3<-as.factor(volcano$major_rock_3)
volcano$major_rock_4<-as.factor(volcano$major_rock_4)
volcano$major_rock_5<-as.factor(volcano$major_rock_5)
volcano$minor_rock_1<-as.factor(volcano$minor_rock_1)
volcano$minor_rock_2<-as.factor(volcano$minor_rock_2)
volcano$minor_rock_3<-as.factor(volcano$minor_rock_3)
volcano$minor_rock_4<-as.factor(volcano$minor_rock_4)
volcano$minor_rock_5<-as.factor(volcano$minor_rock_5)
volcano$last_eruption_year<-as.numeric(gsub("Unknown", NA, volcano$last_eruption_year))
volcano<-volcano%>%
  arrange(primary_volcano_type, last_eruption_year, elevation)%>%
  mutate(years_ago=2020-last_eruption_year)
ordered_columns<-c("volcano_number", "volcano_name", "region", "subregion", "country", "latitude", "longitude", "tectonic_settings", "primary_volcano_type", "elevation", "last_eruption_year", "years_ago", "evidence_category", "population_within_5_km","population_within_10_km","population_within_30_km","population_within_100_km", "major_rock_1","major_rock_2","major_rock_3","major_rock_4","major_rock_5","minor_rock_1","minor_rock_2","minor_rock_3","minor_rock_4","minor_rock_5")
volcano<-volcano[ordered_columns]
volcano
write.table(volcano, file.path(data_sets_path,"updated_volcano_data_set.txt"))
```

___Summary Statistics___

First, we looked at summary statistics for the numeric variables for this data set, which were `elevation`, `last_eruption_year`, `years_ago`, `population_within_5_km`, `population_within_10_km`,`population_within_30_km`, and `population_within_100_km`.. Here, we used the `summary_table()` function from the `qwraps2` package, but couldn't get the grouping figured out properly to display the summary statistics for each variable in its own column in this package. To get around this, we just created an empty matrix, then filled it with the values from the `summary_table()` table. Following this, we compile a table of all the means of relevant numeric data from the `volcano` data set.  We first looked at overall column means for these variables and saved a file of overall means titled `"volcano_dataset_overall_means.txt"`. 
```{r}
volcano_summary <-
  list("elevation" =
         list("min_elevation"       = ~ min(volcano$elevation, na.rm=T),
              "max_elevation"       = ~ max(volcano$elevation, na.rm=T),
              "median_elevation"    = ~ median(volcano$elevation, na.rm=T),
              "mean_elevation"      = ~ mean(volcano$elevation, na.rm=T),
              "variance_elevation"  = ~ var(volcano$elevation, na.rm=T),
              "stdev_elevation"     = ~ sd(volcano$elevation, na.rm=T)),
       "last_eruption_year" =
         list("min_last_eruption_year"       = ~ min(volcano$last_eruption_year, na.rm=T),
              "max_last_eruption_year"       = ~ max(volcano$last_eruption_year, na.rm=T),
              "median_last_eruption_year"    = ~ median(volcano$last_eruption_year, na.rm=T),
              "mean_last_eruption_year"      = ~ mean(volcano$last_eruption_year, na.rm=T),
              "variance_last_eruption_year"  = ~ var(volcano$last_eruption_year, na.rm=T),
              "stdev_last_eruption_year"     = ~ sd(volcano$last_eruption_year, na.rm=T)),
       "years_ago" =
         list("min_years_ago"       = ~ min(volcano$years_ago, na.rm=T),
              "max_years_ago"       = ~ max(volcano$years_ago, na.rm=T),
              "median_years_ago"    = ~ median(volcano$years_ago, na.rm=T),
              "mean_years_ago"      = ~ mean(volcano$years_ago, na.rm=T),
              "variance_years_ago"  = ~ var(volcano$years_ago, na.rm=T),
              "stdev_years_ago"     = ~ sd(volcano$years_ago, na.rm=T)),
       "population_within_5_km" =
         list("min_population_within_5_km"       = ~ min(volcano$population_within_5_km, na.rm=T),
              "max_population_within_5_km"       = ~ max(volcano$population_within_5_km, na.rm=T),
              "median_population_within_5_km"    = ~ median(volcano$population_within_5_km, na.rm=T),
              "mean_population_within_5_km"      = ~ mean(volcano$population_within_5_km, na.rm=T),
              "variance_population_within_5_km"  = ~ var(volcano$population_within_5_km, na.rm=T),
              "stdev_population_within_5_km"     = ~ sd(volcano$population_within_5_km, na.rm=T)),
       "population_within_10_km" =
         list("min_population_within_10_km"       = ~ min(volcano$population_within_10_km, na.rm=T),
              "max_population_within_10_km"       = ~ max(volcano$population_within_10_km, na.rm=T),
              "median_population_within_10_km"    = ~ median(volcano$population_within_10_km, na.rm=T),
              "mean_population_within_10_km"      = ~ mean(volcano$population_within_10_km, na.rm=T),
              "variance_population_within_10_km"  = ~ var(volcano$population_within_10_km, na.rm=T),
              "stdev_population_within_10_km"     = ~ sd(volcano$population_within_10_km, na.rm=T)),
       "population_within_30_km" =
         list("min_population_within_30_km"       = ~ min(volcano$population_within_30_km, na.rm=T),
              "max_population_within_30_km"       = ~ max(volcano$population_within_30_km, na.rm=T),
              "median_population_within_30_km"    = ~ median(volcano$population_within_30_km, na.rm=T),
              "mean_population_within_30_km"      = ~ mean(volcano$population_within_30_km, na.rm=T),
              "variance_population_within_30_km"  = ~ var(volcano$population_within_30_km, na.rm=T),
              "stdev_population_within_30_km"     = ~ sd(volcano$population_within_30_km, na.rm=T)),
       "population_within_100_km" =
         list("min_population_within_100_km"       = ~ min(volcano$population_within_100_km, na.rm=T),
              "max_population_within_100_km"       = ~ max(volcano$population_within_100_km, na.rm=T),
              "median_population_within_100_km"    = ~ median(volcano$population_within_100_km, na.rm=T),
              "mean_population_within_100_km"      = ~ mean(volcano$population_within_100_km, na.rm=T),
              "variance_population_within_100_km"  = ~ var(volcano$population_within_100_km, na.rm=T),
              "stdev_population_within_100_km"     = ~ sd(volcano$population_within_100_km, na.rm=T))
       )
volcano_summary_table<-as.data.frame(summary_table(volcano, summaries=volcano_summary))
formatted_volcano_stats<-matrix(ncol=7, nrow=6)
colnames(formatted_volcano_stats)<-c("elevation", "last_eruption_year", "years_ago", "population_within_5_km", "population_within_10_km", "population_within_30_km", "population_within_100_km")
rownames(formatted_volcano_stats)<-c("minimum", "maximum", "median", "mean", "variance", "stdev")
formatted_volcano_stats[1:6, 1]<-volcano_summary_table[1:6, 1]
formatted_volcano_stats[1:6, 2]<-volcano_summary_table[7:12, 1]
formatted_volcano_stats[1:6, 3]<-volcano_summary_table[13:18, 1]
formatted_volcano_stats[1:6, 4]<-volcano_summary_table[19:24, 1]
formatted_volcano_stats[1:6, 5]<-volcano_summary_table[25:30, 1]
formatted_volcano_stats[1:6, 6]<-volcano_summary_table[31:36, 1]
formatted_volcano_stats[1:6, 7]<-volcano_summary_table[37:42, 1]
formatted_volcano_stats<-as.data.frame(formatted_volcano_stats)

overall_means<-data.frame(mean(volcano$elevation),
mean(volcano$last_eruption_year, na.rm=T),
mean(volcano$years_ago, na.rm=T),
mean(volcano$population_within_5_km, na.rm=T),
mean(volcano$population_within_10_km, na.rm=T),
mean(volcano$population_within_30_km, na.rm=T),
mean(volcano$population_within_100_km, na.rm=T))
names(overall_means)<-c("elevation", "last_eruption_year", "years_ago", "population_within_5_km", "population_within_10_km","population_within_30_km", "population_within_100_km")
row.names(overall_means)<-c("overall_means")
overall_means
write.table(overall_means, file.path(summary_text_path, "volcano_dataset_overall_means.txt"))
```

Then we looked at means based on the `primary_volcano_type` variable. We rounded each of these to whole units. Finally, we saved a file with the means for each variable by primary volcano type, titled `"volcano_dataset_means_by_primary_volcano_type.txt"`.
```{r}
elevation_means<-volcano%>%
  group_by(primary_volcano_type)%>%
  summarise(mean_height = mean(elevation))
elevation_means<-elevation_means[order(-elevation_means$mean_height),]
elevation_means$mean_height<-round(elevation_means$mean_height,0)

last_eruption_year_means<-volcano%>%
  group_by(primary_volcano_type)%>%
  summarise(mean_year = mean(last_eruption_year, na.rm=T))
last_eruption_year_means<-last_eruption_year_means[order(-last_eruption_year_means$mean_year),]
last_eruption_year_means$mean_year<-round(last_eruption_year_means$mean_year,0)

years_ago<-volcano%>%
  group_by(primary_volcano_type)%>%
  summarise(mean_years_ago=mean(years_ago, na.rm=T))
years_ago$mean_years_ago<-round(years_ago$mean_years_ago, 0)

five_km_pop_means<-volcano%>%
  group_by(primary_volcano_type)%>%
  summarise(mean_5km_pop=mean(population_within_5_km, na.rm=T))
five_km_pop_means$mean_5km_pop<-round(five_km_pop_means$mean_5km_pop, 0)

ten_km_pop_means<-volcano%>%
  group_by(primary_volcano_type)%>%
  summarise(mean_10km_pop=mean(population_within_10_km, na.rm=T))
ten_km_pop_means$mean_10km_pop<-round(ten_km_pop_means$mean_10km_pop, 0)

thirty_km_pop_means<-volcano%>%
  group_by(primary_volcano_type)%>%
  summarise(mean_30km_pop=mean(population_within_30_km, na.rm=T))
thirty_km_pop_means$mean_30km_pop<-round(thirty_km_pop_means$mean_30km_pop, 0)

hundred_km_pop_means<-volcano%>%
  group_by(primary_volcano_type)%>%
  summarise(mean_100km_pop=mean(population_within_100_km, na.rm=T))
hundred_km_pop_means$mean_100km_pop<-round(hundred_km_pop_means$mean_100km_pop, 0)

volcano_means_table <- merge(merge(merge(merge(merge(merge(
  elevation_means,
  last_eruption_year_means, all=T),
  years_ago, all=T),
  five_km_pop_means, all=T),
  ten_km_pop_means, all=T),
  thirty_km_pop_means, all=T),
  hundred_km_pop_means, all=T)
volcano_means_table
write.table(volcano_means_table, file.path(summary_text_path, "volcano_dataset_means_by_primary_volcano_type.txt"))
```

___Types of Volcanoes___

Here we create a bar chart to show the types of volcanos present among the provided data. Based on this chart, we can see that, by a large margin, stratovolcanos are the most common type of volcano.

```{r}
type_count<-volcano %>% 
  group_by(primary_volcano_type) %>%
  summarise(no_rows1 = length(primary_volcano_type))

ggplot(volcano, aes(x=primary_volcano_type))+
  geom_bar(col="blue", fill="blue")+
  ggtitle("Number of Volcanos by Type")+
  labs(x="Type of Volcano", y="Number of Volcanos")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  geom_text(data=type_count, aes(x=primary_volcano_type, y=no_rows1, label=no_rows1), nudge_y=30)+
  ggsave(file.path(figure_path,"volcano_count_by_type.pdf"))
```

Here we create a bar chart showing the number of volcanos in each tectonic subcategory. Here we can see that the most common tectonic setting is for subduction zone / continental crust.
```{r}
tectonic_count<-volcano %>% 
  group_by(tectonic_settings) %>%
  summarise(no_rows3 = length(tectonic_settings))

ggplot(volcano, aes(x=tectonic_settings))+
  geom_bar(col="orange", fill="orange")+
  ggtitle("Number of Volcanos by Tectonic Setting")+
  labs(x="Tectonic Setting", y="Number of Volcanos")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.95))+
  geom_text(data=tectonic_count ,aes(x=tectonic_settings, y=no_rows3, label=no_rows3), nudge_y=50)+
  scale_x_discrete(labels = function(tectonic_settings) str_wrap(tectonic_settings, width = 20))+
   ggsave(file.path(figure_path, "volcano_count_by_tectonic_setting.pdf"))
```

__Volcanos by Evidence Category__

Here is a bar chart showing how many volcanos have different types of known evidence of past eruptions. Here, we can see that most volcano eruptions have been observed. However, a sizable number have also been dated using various dating methods. Others, while not directly observed or dated, do have credible evidence. Comparatively, relatively few have uncertain eruption evidence.
```{r}
evidence_count<-volcano %>% 
  group_by(evidence_category) %>%
  summarise(no_rows4 = length(evidence_category))

ggplot(volcano, aes(x=evidence_category))+
  geom_bar(fill="light blue")+
  ggtitle("Number of Volcanos by Evidence Category")+
  labs(x="Evidence Category", y="Number of Volcanos")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  geom_text(data=evidence_count ,aes(x=evidence_category, y=no_rows4, label=no_rows4), nudge_y=30)+
   ggsave(file.path(figure_path, "volcano_count_by_evidence.pdf"))
```

___Elevation___

Here is a histogram showing the frequency of different volcano heights. The majority of volcanos are under 2,500 feet tall, with most being 1,000 to 1,500 feet tall. The data do appear to be moderately skewed to the right.
```{r}
ggplot(volcano, aes(x=elevation))+
  geom_histogram(binwidth=500, col="black", fill="gold")+
  ggtitle("Histogram of Volcano Elevations")+
  labs(x="Elevation", y="Observations")+
  theme(panel.grid=element_blank())+
  ggsave(file.path(figure_path, "volcano_elevation_histogram.pdf"))
```

___Eruption Dates___

This is a histogram showing the number of volcanos that have a known eruption within a certian number of years in the past. Currently, the bin width is set at 1,000 years. However, this doesn't discriminate well for the most recent years. Something needs to be done to split up the more recent and the older data.
```{r}
ggplot(volcano, aes(x=last_eruption_year))+
  geom_histogram(binwidth=1000, color="black", fill="pink")+
  ggtitle("Histogram of Last Known Eruptions")+
  labs(x="Date", y="Observations")+
  theme(panel.grid=element_blank())+
  ggsave(file.path(figure_path, "last_eruption_year_histogram.pdf"))
```

__Multiple Comparisons through ANOVA__

For the following features we are conducting ANOVAs to identify significant differences between means for different variables. Here we use the `car` package for the Levene's Test of Homogeneity of Variance using `leveneTest()`. Normal distribution of residuals is evaluated using the `shapiro.test()` function. Under normal circumstances, homogeneity of variance and normality of residuals would be considered prerequisite assumptions for running an ANOVA; however, for the purpose of this project, for all data, we treat the data as if the assumptions have been met, even if they are demonstrably not. Linear models are constructed, ANOVA assumptions are tested, and ANOVA is carried out. Then, boxplots are constructed to visually display the data. Tukey's HSD is also conducted as a post hoc test using the `hsd.test()` function from the `agricolae` package and, where appropriate, is plotted on these boxplots to show groups that are signifcantly different from one another.

___Multiple Comparisons of Elevation by Volcano Type___

Here, we can see that neither normality of residuals or homogeneity of variance are met, but carry on with ANOVA for demonstration purposes. Based on the results of the ANOVA, at alpha = 0.05, we reject the null hypothesis and conclude that at least one mean elevation is different from the rest. The results of Tukey's HSD visualized on the boxplot show that mean submarine elevation is statistically different than all but three other volcano types. However, all above-sea level volcanoes are not statistically different than one another.
```{r}
mean(volcano$elevation)

#Ho: All mean elevations are equal among volcano types.
#HA: At least one mean elevation is different.
model1=lm(elevation~primary_volcano_type, data=volcano)
res_values1<-residuals(model1)
shapiro.test(res_values1)
leveneTest(model1)
elevation_anova<-aov(model1)
summary(elevation_anova)
hsd1=HSD.test(elevation_anova, "primary_volcano_type", group=T)


ggplot(volcano, aes(x=reorder(primary_volcano_type, elevation, na.rm=T), y=elevation))+
  geom_boxplot(fill="cyan")+
  ggtitle("Boxplot of Volcano Elevation by Volcano Type")+
  labs(x="Elevation (Meters above Sea Level)", y="Volcano Type")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  stat_summary(fun=mean, geom="point", pch="+", size=2.5, color="red", fill="red")+
  geom_text(elevation_means, mapping=aes(x=reorder(primary_volcano_type, mean_height), y=mean_height,label=hsd1$groups$groups, vjust=-2.25, hjust=-0.25))+
  ggsave(file.path(figure_path, "elevation_by_type_boxplot.pdf"))
```

___Multiple Comparisons of Last Known Eruption by Volcano Type and Tectonic Setting___

This analysis seeks to determine whether or not certain types of volcanoes are more likely to erupt than others based on their last known eruption date. In this boxplot, the further down the y-axis, the longer it has been since an eruption. Here again, we can see that neither normality of residuals or homogeneity of variance are met. Based on the results of the ANOVA, at alpha = 0.05, we reject the null hypothesis and conclude that at least one mean last eruption year is different from the rest among volcano types. From the post hoc test, two age groups emerge, with four tectonic settings overlapping between these groups.
```{r}
#Ho: Mean last eruption year is equal among all volcano types
#HA: At least one mean eruption year is not equal
model2=lm(last_eruption_year~primary_volcano_type, data=volcano)
res_values2<-residuals(model2)
shapiro.test(res_values2)
leveneTest(model2)
eruption_year_anova<-aov(model2)
summary(eruption_year_anova)
hsd2=HSD.test(eruption_year_anova, "primary_volcano_type", group=T)

ggplot(volcano, aes(x=reorder(primary_volcano_type, last_eruption_year, na.rm=T), y=last_eruption_year))+
  geom_boxplot(fill="yellow")+
  ggtitle("Boxplot of Last Eruption Year by Volcano Type")+
  labs(x="Year", y="Volcano Type")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  stat_summary(fun=mean, geom="point", pch="+", size=2.5, color="red", fill="red")+
   ggsave(file.path(figure_path, "eruption_year_by_type_boxplot.pdf"))
```

Much like above, this analysis seeks to determine if volcanos in different tectonic settings, rather than just different volcano types, are more likely than others to erupt more frequently. Here again, the rationale is that the further down the y-axis, the longer it has been since an eruption. While the model assumptions are not met, in our demonstration we find that at alpha = 0.05, we reject the null hypothesis and conclude that at least one mean last eruption year is different from the rest among tectonic settings.
```{r}
last_eruption_year_means2<-volcano%>%
  group_by(tectonic_settings)%>%
  summarise(mean_year = mean(last_eruption_year, na.rm=T))%>%
  filter(tectonic_settings!="Unknown")
last_eruption_year_means2<-last_eruption_year_means2[order(-last_eruption_year_means2$mean_year),]
last_eruption_year_means2$mean_year<-round(last_eruption_year_means2$mean_year,0)

#Ho: Mean last eruption year is equal among all tectonic settings.
#HA: At least one mean eruption year is not equal.
model3=lm(last_eruption_year~tectonic_settings, data=volcano)
res_values3<-residuals(model3)
shapiro.test(res_values3)
leveneTest(model3)
eruption_tectonic_anova<-aov(model3)
summary(eruption_tectonic_anova)
hsd3=HSD.test(eruption_tectonic_anova, "tectonic_settings", group=T)

ggplot(volcano, aes(x=reorder(tectonic_settings, last_eruption_year, na.rm=T), y=last_eruption_year))+
  geom_boxplot(fill="orange")+
  ggtitle("Boxplot of Last Eruption Year by Tectonic Setting")+
  labs(x="Tectonic Setting", y="Year")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.95))+
  stat_summary(fun=mean, geom="point", pch="+", size=2.5, color="red", fill="red")+
  geom_text(last_eruption_year_means2, mapping=aes(x=reorder(tectonic_settings, mean_year), y=mean_year,label=hsd3$groups$groups, vjust=2.25, hjust=-0.25))+
  scale_x_discrete(labels = function(tectonic_settings) str_wrap(tectonic_settings, width = 20))+
   ggsave(file.path(figure_path, "last_eruption_year_by_tectonic_setting.pdf"))
```

___Populations within Specified Radius of Volcano Types and Multiple Comparisions___

Here, we are showing the number of people that live within 5, 10, 30, and 100 km of different volcano types. While we had initially planned to show this as boxplot data, there were several extreme outliers that were compressing the data. While we could have adjusted the axes to exclude these, we did not feel that this would represent the data well. Instead, we plot mean populations living within the specified range of each volcano type as bar charts. A word of caution for the bar plots that follow, because the outliers were so severe, they do skew the mean values reported. After showing these bar charts of mean values, we look for significant differences between means using ANOVA, then conduct Tukey's HSD as a post hoc test. Here again, we check the assumptions for each ANOVA, but treat all analyses as if the assumptions have been met for demonstration purposes.

Based on each ANOVA result, at alpha = 0.05, we reject each null hypothesis, and conclude that at each distance, there is a significant difference in the mean population.
```{r, figures-side, fig.show="hold"}
population_means_by_volcano_type<-group_by(volcano, primary_volcano_type) %>% 
  summarize(mean_population_within_5_km = mean(population_within_5_km), mean_population_within_10_km = mean(population_within_10_km), mean_population_within_30_km = mean(population_within_30_km), mean_population_within_100_km = mean(population_within_100_km))
population_means_by_volcano_type[,2:5]<-round(population_means_by_volcano_type[,2:5],digits=0)

ggplot(population_means_by_volcano_type, aes(x=primary_volcano_type, y=mean_population_within_5_km))+
  geom_col(fill="red")+
  ggtitle("Mean Population Living within 5km of Volcanos by Volcano Type")+
  labs(x="Volcano Type", y="Mean Population within 5km")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  geom_text(data=population_means_by_volcano_type, aes(x=primary_volcano_type, y=mean_population_within_5_km, label=mean_population_within_5_km), nudge_y=10000, size=3)+
  ggsave(file.path(figure_path, "mean_5km_pop_by_type_barplot.pdf"))

ggplot(population_means_by_volcano_type, aes(x=primary_volcano_type, y=mean_population_within_10_km))+
  geom_col(fill="green")+
  ggtitle("Mean Population Living within 10km of Volcanos by Volcano Type")+
  labs(x="Volcano Type", y="Mean Population within 10km")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  geom_text(data=population_means_by_volcano_type, aes(x=primary_volcano_type, y=mean_population_within_10_km, label=mean_population_within_10_km), nudge_y=10000, size=3)+
  ggsave(file.path(figure_path, "mean_10km_pop_by_type_barplot.pdf"))

ggplot(population_means_by_volcano_type, aes(x=primary_volcano_type, y=mean_population_within_30_km))+
  geom_col(fill="orange")+
  ggtitle("Mean Population Living within 30km of Volcanos by Volcano Type")+
  labs(x="Volcano Type", y="Mean Population within 30km")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  geom_text(data=population_means_by_volcano_type, aes(x=primary_volcano_type, y=mean_population_within_30_km, label=mean_population_within_30_km), nudge_y=25000, size=3)+
  ggsave(file.path(figure_path, "mean_30km_pop_by_type_barplot.pdf"))

ggplot(population_means_by_volcano_type, aes(x=primary_volcano_type, y=mean_population_within_100_km))+
  geom_col(fill="blue")+
  ggtitle("Mean Population Living within 100km of Volcanos by Volcano Type")+
  labs(x="Volcano Type", y="Mean Population within 100km")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  geom_text(data=population_means_by_volcano_type, aes(x=primary_volcano_type, y=mean_population_within_100_km, label=mean_population_within_100_km), nudge_y=175000, size=3)+
ggsave(file.path(figure_path, "mean_100km_pop_by_type_barplot.pdf"))

#5km population means
#Ho: All populations are equal among volcano types
#HA: At least one mean population is different
model4=lm(population_within_5_km~primary_volcano_type, data=volcano)
res_values4<-residuals(model4)
shapiro.test(res_values4)
leveneTest(model4)
five_km_anova<-aov(model4)
summary(five_km_anova)
hsd4=HSD.test(five_km_anova, "primary_volcano_type", group=T)
hsd4

#10km population means
#Ho: All populations are equal among volcano types
#HA: At least one mean population is different
model5=lm(population_within_10_km~primary_volcano_type, data=volcano)
res_values5<-residuals(model5)
shapiro.test(res_values5)
leveneTest(model5)
ten_km_anova<-aov(model5)
summary(ten_km_anova)
hsd5=HSD.test(ten_km_anova, "primary_volcano_type", group=T)
hsd5

#30km population means
#Ho: All populations are equal among volcano types
#HA: At least one mean population is different
model6=lm(population_within_30_km~primary_volcano_type, data=volcano)
res_values6<-residuals(model6)
shapiro.test(res_values6)
leveneTest(model6)
thirty_km_anova<-aov(model6)
summary(thirty_km_anova)
hsd6=HSD.test(thirty_km_anova, "primary_volcano_type", group=T)
hsd6

#100km population means
#Ho: All populations are equal among volcano types
#HA: At least one mean population is different
model7=lm(population_within_100_km~primary_volcano_type, data=volcano)
res_values7<-residuals(model7)
shapiro.test(res_values7)
leveneTest(model7)
hundred_km_anova<-aov(model7)
summary(hundred_km_anova)
hsd7=HSD.test(hundred_km_anova, "primary_volcano_type", group=T)
hsd7
```

___Linear Regression and Correlation of Volcano Elevation with Last Known Eruption Year___

Here, a reasonable assumption that could be made about volcanos is that ones that erupt more frequently are taller because they are adding more layers of molten rock to their outer surface. To test this assumption, we performed linear regression analysis between last known eruption year and elevation. Based off of the results of this analysis, at alpha = 0.05, we reject the null hypothesis and conclude that no significant linear relationship exists between elevation and last known eruption year. Since we detail the process involved in checking the assumptions required for linear regression elsewhere in this project, we are assuming that the assumptions have been met here for demonstration purposes, even though they might not necessarily be met. 
```{r}
#Ho: Slope = 0 (no linear relationship)
#HA: Slope not equal to 0 (linear relationship)

ggplot(volcano, aes(x=last_eruption_year, y=elevation))+
  geom_point(alpha=1/5)+
  ggtitle("Last Eruption Year vs Elevation")+
  labs(x="Year", y="Elevation")+
  theme(panel.grid=element_blank())+
  stat_cor()+
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)+
  ggsave(file.path(figure_path, "elevation_vs_eruption_year_correlation.pdf"))
```

___Global Volcano Locations___

Here we create a bar chart showing the number of volcanos present in various regions of the world. Since actual latitude and longitude coordinates were provided in this data file, following this regional grouping bar chart, we used the `threejs` package to plot each of the coordinates on a global map. Height of individual bars on the map represent volcano elevation, while heatmap colors indicate the number of years since the last known eruption (white = most recent, red = most distant past). The globe can be toggled for a 360 degree view of the globe using the cursor.
```{r}
region_count<-volcano %>% 
  group_by(region) %>%
  summarise(no_rows2 = length(region))

ggplot(volcano, aes(x=region))+
  geom_bar(fill="pink")+
  ggtitle("Number of Volcanos by Region")+
  labs(x="Region", y="Number of Volcanos")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.95))+
  geom_text(data=region_count ,aes(x=region, y=no_rows2, label=no_rows2), nudge_y=10)+
  ggsave(file.path(figure_path, "volcano_count_by_region.pdf"))

for_globe<-volcano[,c("latitude", "longitude", "years_ago", "elevation")]
colors=as.numeric(cut(for_globe$years_ago,
                      breaks=1000, include.lowest=T, na.rm=T))
colors=heat.colors(colors)
globejs(lat=for_globe$latitude, long=for_globe$longitude, val=(0.025*for_globe$elevation), color=colors, atmosphere=T, pointsize=0.75, emissive=T)
```

__Eruptions Dataset__

The `eruptions` data set contains information related to volcanic eruptions for individually named volcanos. Among this information is the VEI, or volcanic explosivity index, which is a measure of the intensity of past volcanic eruptions. Additionally, start and end dates for eruptions are provided with individual columns for day, month, and year. Location is provided with latitude and longitude, while observations such as type of methodology used for dating past eruptions is also included. For the purpose of this project, we are focusing primarily on the main numeric data in this file, the VEI.

___Eruption Intensity by VEI___

Plotted below is a simple histogram showing the distribution of VEI across recorded volcanic eruptions. As seen in the histogram, most past eruptions have a VEI of 2, which is toward the low end of the scale. There is some right skew to the data as well.
```{r}
#simple histogram showing the number of eruptions of differing intesities
hist(eruptions$vei, main = "Volcano eruption index frequency", xlab = "Volcano eruption index", ylab = "Frequency")

################################## Leo, take a look at this histogram and see if it looks better than the base package one that you included initially. We can choose which one we want to keep for the final draft.

mean(eruptions$vei, na.rm=T)

ggplot(eruptions, aes(x=vei))+
  geom_histogram(binwidth=1, col="black", fill="cyan")+
  ggtitle("Histogram of Volcanic Eruption Index")+
  labs(x="VEI", y="Number of Observaitons")+
  theme(panel.grid = element_blank())
```
___Need to include a more descriptive description here___

```{r}
#interesting graphs showing the distribution of vei over longitude and latitude
#y axis is intensity and the x axis is longitude, size of dot = the number of observations at that given latitude
ggplot(eruptions, aes(x=latitude, y=vei))+
  geom_count(na.rm = T)+
  ggtitle("Volcano eruption index distributed over latitude")+
  labs(x="Latitude", y="vei")

ggplot(eruptions, aes(x=longitude, y=vei))+
  geom_count(na.rm = T)+
  ggtitle("Volcano eruption index distributed over longitude")+
  labs(x="Longitude", y="vei")
```

___Eruption Length Categorized by VEI___

The only numeric data that this file contains is `vei`, `latitude`, `longitude`, and the various columns for start and end day, month, and year. Out of these existing values, it only makes sense to calculate the mean of the VEI, which we showed in addition to the previous histogram. However, we can create an additional column from this data for the length of each eruption in days. We first must put the day, month, and year in the same column for the start and end dates, then convert these values to dates using the `as.Date()` function from base R. Then, we can use `mutate()` to take the end date minus the start date to get length of eruption in days. Following this step, we can create jitter plots that show the different day at specified levels of VEI. Because there are several outliers that compress the data, we created a second jitter plot that shows only data within one standard deviation of the mean lenght of eruption. We can see that eruption lengths vary widely within individual VEI categories.
```{r}
eruptions_updated<-eruptions%>%
  transform(start_date=interaction(start_year, start_month, start_day, sep="-"))%>%
  transform(end_date=interaction(end_year, end_month, end_day, sep="-"))
eruptions_updated$start_date<-as.Date(eruptions_updated$start_date)
eruptions_updated$end_date<-as.Date(eruptions_updated$end_date)
eruptions_updated$vei<-as.factor(eruptions_updated$vei)
eruptions_updated<-eruptions_updated%>%
  mutate(eruption_length_in_days=end_date - start_date)
eruptions_updated$eruption_length_in_days<-as.numeric(eruptions_updated$eruption_length_in_days)

#All Data Points
ggplot(eruptions_updated, aes(x=vei, y=eruption_length_in_days))+
  geom_jitter(aes(color=vei), alpha=1/5, show.legend=F)+
  ggtitle("Eruption Length in Days by VEI")+
  labs(x="VEI", y="Eruption Lenght (Days)")+
  theme(panel.grid = element_blank())

mean(eruptions_updated$eruption_length_in_days, na.rm=T)+sd(eruptions_updated$eruption_length_in_days, na.rm=T)

#Data Points within One SD of Mean
ggplot(eruptions_updated, aes(x=vei, y=eruption_length_in_days))+
  geom_jitter(aes(color=vei), alpha=1/2, show.legend = F)+
  ylim(0,2465)+
  ggtitle("Eruption Length in Days by VEI - Within One Standard Deviation")+
  labs(x="VEI", y="Eruption Lenght (Days)")+
  theme(panel.grid = element_blank())
```

___Methods of Dating Past Volcanic Eruptions___

Here we create several bar plots displaying the different methods used for dating various eruptions of volcanos. The first plot is of the raw data. A high number of individuals categorized as "Historical Observations" compresses the rest of the bars in the plot, so we remove all individuals with "Historical Observations" to create the new data set `eruptions2`. Then, we create a new bar plot that includes all methods used besides "Historical Observations". As can be seen, visualization of the different amounts is made much easier by removing this factor.
```{r}
ggplot(eruptions, aes(x=evidence_method_dating))+
  geom_bar(fill="red")+
  ggtitle("Prevalence of Different Eruption Dating Methods")+
  labs(x="Evidence Dating Methods", y="Number of Eruptions")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 40, hjust = 1, vjust = 1))

eruptions2 <- filter(eruptions, evidence_method_dating != "Historical Observations")

evidence_count2<-eruptions2 %>% 
  group_by(evidence_method_dating) %>%
  summarise(no_rows5 = length(evidence_method_dating))

ggplot(eruptions2, aes(x=evidence_method_dating))+
  geom_bar(fill="purple")+
  ggtitle("Prevalence of Different Eruption Dating Methods")+
  labs(x="Evidence Dating Methods", y="Number of Eruptions")+
  theme(panel.grid=element_blank(), axis.text.x = element_text(angle = 40, hjust = 1, vjust = 1))+
  geom_text(data=evidence_count2, aes(x=evidence_method_dating, y=no_rows5, label=no_rows5), nudge_y=60)
```

